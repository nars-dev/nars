// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Instance = require("./Instance.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_SetString = require("bs-platform/lib/js/belt_SetString.js");
var Belt_HashMapInt = require("bs-platform/lib/js/belt_HashMapInt.js");
var ReactReconciler = require("react-reconciler");
var ComponentRegistry = require("./ComponentRegistry.bs.js");

function createInstance(instance_type, props, _rootContainer, _context, fiber) {
  var key = fiber.key;
  return ComponentRegistry.createInstance(instance_type, key === null ? undefined : Caml_option.some(key), props);
}

function getPublicInstance(x) {
  return x;
}

function getRootHostContext(param) {
  return /* () */0;
}

function getChildHostContext(parentHostContext, param, param$1) {
  return parentHostContext;
}

function prepareForCommit(param) {
  return /* () */0;
}

function resetAfterCommit(container) {
  Belt_HashMapInt.clear(container.callbackRegistry);
  var counter = {
    contents: 0
  };
  var registerCallback = function (callback) {
    var id = counter.contents;
    counter.contents = counter.contents + 1 | 0;
    Belt_HashMapInt.set(container.callbackRegistry, id, callback);
    return id;
  };
  var children = container.children.map((function (inst) {
          return Instance.encode(inst, registerCallback);
        }));
  Curry._1(container.flushUpdates, children);
  return /* () */0;
}

function assertComponentInstance(instance, f) {
  if (instance.tag) {
    return Curry._1(f, instance[0]);
  } else {
    return Pervasives.invalid_arg("Cannot append children to RawText");
  }
}

function appendInitialChild(parentInstance, child) {
  assertComponentInstance(parentInstance, (function (parentInstance) {
          return parentInstance.children.push(child);
        }));
  return /* () */0;
}

function finalizeInitialChildren(param, param$1, param$2, param$3, _hostContext) {
  return false;
}

function prepareUpdate(param, param$1, oldProps, newProps, param$2, param$3) {
  var oldProps$1 = oldProps;
  var newProps$1 = newProps;
  var changedProps = /* array */[];
  var newSet = Belt_SetString.fromArray(Object.keys(newProps$1));
  var oldSet = Belt_SetString.fromArray(Object.keys(oldProps$1));
  Belt_SetString.forEachU(Belt_SetString.union(newSet, oldSet), (function (key) {
          if (Js_dict.get(newProps$1, key) !== Js_dict.get(oldProps$1, key)) {
            changedProps.push(key);
            return /* () */0;
          } else {
            return /* () */0;
          }
        }));
  return changedProps;
}

function createTextInstance(text, param, param$1, param$2) {
  return /* RawText */Block.__(0, [text]);
}

function shouldSetTextContent(param, _props) {
  return false;
}

function shouldDeprioritizeSubtree(param, param$1) {
  return false;
}

function mountEventComponent(param) {
  return Pervasives.failwith("Event components are not implemented");
}

function handleEventTarget(param) {
  return Pervasives.failwith("Event components are not implemented");
}

function commitEventTarget(param) {
  return Pervasives.failwith("Event components are not implemented");
}

function getChildHostContextForEventComponent(param) {
  return Pervasives.failwith("Event components are not implemented");
}

function getChildHostContextForEventTarget(param) {
  return Pervasives.failwith("Event components are not implemented");
}

function getEventTargetChildElement(param, param$1) {
  return Pervasives.failwith("Event components are not implemented");
}

var appendChild = appendInitialChild;

function appendChildToContainer(container, child) {
  container.children.push(child);
  return /* () */0;
}

function commitMount(param, param$1, param$2, param$3) {
  return /* () */0;
}

function commitUpdate(instance, param, instance_type, param$1, props, param$2) {
  if (instance.tag) {
    instance[0].props = /* Props */[props];
    return /* () */0;
  } else {
    return Pervasives.invalid_arg("Cannot update component type " + instance_type);
  }
}

function insertBefore(parent, child, beforeChild) {
  return assertComponentInstance(parent, (function (parentInstance) {
                var index = parentInstance.children.findIndex((function (x) {
                        return beforeChild === x;
                      }));
                parentInstance.children.splice(index, 0, child);
                return /* () */0;
              }));
}

function insertInContainerBefore(container, child, beforeChild) {
  var index = container.children.findIndex((function (x) {
          return beforeChild === x;
        }));
  container.children.splice(index, 0, child);
  return /* () */0;
}

function removeChild(parent, child) {
  return assertComponentInstance(parent, (function (parent) {
                var pos = parent.children.findIndex((function (x) {
                        return child === x;
                      }));
                parent.children.splice(pos, 1);
                return /* () */0;
              }));
}

function removeChildFromContainer(parent, child) {
  var pos = parent.children.findIndex((function (x) {
          return child === x;
        }));
  parent.children.splice(pos, 1);
  return /* () */0;
}

function hideInstance(param) {
  return /* () */0;
}

function unhideInstance(param, param$1) {
  return /* () */0;
}

function commitTextUpdate(param, param$1, param$2) {
  return /* () */0;
}

function hideTextInstance(param) {
  return /* () */0;
}

function unhideTextInstance(param, param$1) {
  return /* () */0;
}

function resetTextContent(param) {
  return /* () */0;
}

var reconciler = ReactReconciler({
      supportsMutation: true,
      getPublicInstance: getPublicInstance,
      getRootHostContext: getRootHostContext,
      getChildHostContext: getChildHostContext,
      prepareForCommit: prepareForCommit,
      resetAfterCommit: resetAfterCommit,
      createInstance: createInstance,
      appendInitialChild: appendInitialChild,
      finalizeInitialChildren: finalizeInitialChildren,
      prepareUpdate: prepareUpdate,
      createTextInstance: createTextInstance,
      shouldSetTextContent: shouldSetTextContent,
      shouldDeprioritizeSubtree: shouldDeprioritizeSubtree,
      now: (function (prim) {
          return Date.now();
        }),
      cancelTimeout: (function (prim) {
          clearTimeout(prim);
          return /* () */0;
        }),
      scheduleTimeout: (function (prim, prim$1) {
          return setTimeout(prim, prim$1);
        }),
      noTimeout: -1,
      isPrimaryRenderer: true,
      mountEventComponent: mountEventComponent,
      handleEventTarget: handleEventTarget,
      commitEventTarget: commitEventTarget,
      getChildHostContextForEventComponent: getChildHostContextForEventComponent,
      getChildHostContextForEventTarget: getChildHostContextForEventTarget,
      getEventTargetChildElement: getEventTargetChildElement,
      appendChild: appendChild,
      appendChildToContainer: appendChildToContainer,
      commitMount: commitMount,
      commitUpdate: commitUpdate,
      insertBefore: insertBefore,
      insertInContainerBefore: insertInContainerBefore,
      removeChild: removeChild,
      removeChildFromContainer: removeChildFromContainer,
      hideInstance: hideInstance,
      unhideInstance: unhideInstance,
      commitEventTarget: commitEventTarget,
      commitTextUpdate: commitTextUpdate,
      hideTextInstance: hideTextInstance,
      unhideTextInstance: unhideTextInstance,
      resetTextContent: resetTextContent
    });

function createContainer(flushUpdates) {
  var registry = Belt_HashMapInt.make(50);
  var opaqueRoot = reconciler.createContainer({
        flushUpdates: flushUpdates,
        children: /* array */[],
        callbackRegistry: registry
      });
  return {
          registry: registry,
          opaqueRoot: opaqueRoot
        };
}

function updateContainer(element, container) {
  return reconciler.updateContainer(element, container.opaqueRoot);
}

function unbatchedUpdates(f) {
  return reconciler.unbatchedUpdates(f);
}

function invokeCallback(container, messageId, args) {
  var match = Belt_HashMapInt.get(container.registry, messageId);
  if (match !== undefined) {
    return Curry._1(match, args);
  } else {
    return /* () */0;
  }
}

function batchedUpdates(f) {
  return reconciler.batchedUpdates(f, /* () */0);
}

function flushPassiveEffects(param) {
  return reconciler.flushPassiveEffects();
}

var isThisRendererActing = reconciler.IsThisRendererActing;

var nullElement = null;

exports.createContainer = createContainer;
exports.updateContainer = updateContainer;
exports.unbatchedUpdates = unbatchedUpdates;
exports.invokeCallback = invokeCallback;
exports.batchedUpdates = batchedUpdates;
exports.flushPassiveEffects = flushPassiveEffects;
exports.isThisRendererActing = isThisRendererActing;
exports.nullElement = nullElement;
/* reconciler Not a pure module */
