/* TypeScript file generated by genType. */
/* eslint-disable import/first */


const $$toRE922137290: { [key: string]: any } = {"Extend": 0, "Clamp": 1, "Identity": 2};

// tslint:disable-next-line:no-var-requires
const Curry = require('bs-platform/lib/js/curry.js');

// tslint:disable-next-line:no-var-requires
const AnimatedBS = require('./Animated.bs');

// tslint:disable-next-line:max-classes-per-file 
export abstract class AnimatedAdaptable_t { protected opaque!: any }; /* simulate opaque types */

// tslint:disable-next-line:max-classes-per-file 
export abstract class AnimatedValue_t { protected opaque!: any }; /* simulate opaque types */

// tslint:disable-next-line:max-classes-per-file 
export abstract class AnimatedNode_t { protected opaque!: any }; /* simulate opaque types */

// tslint:disable-next-line:max-classes-per-file 
export abstract class Clock_t { protected opaque!: any }; /* simulate opaque types */

// tslint:disable-next-line:max-classes-per-file 
export abstract class Clock_operation { protected opaque!: any }; /* simulate opaque types */

// tslint:disable-next-line:interface-over-type-literal
export type clock = Clock_t;

// tslint:disable-next-line:interface-over-type-literal
export type clockOperation = Clock_operation;

// tslint:disable-next-line:interface-over-type-literal
export type animatedValue = AnimatedValue_t;

// tslint:disable-next-line:interface-over-type-literal
export type adaptable = AnimatedAdaptable_t;

// tslint:disable-next-line:interface-over-type-literal
export type node = AnimatedNode_t;

// tslint:disable-next-line:interface-over-type-literal
export type extrapolate = "Extend" | "Clamp" | "Identity";

// tslint:disable-next-line:interface-over-type-literal
export type interpolationConfig = {
  readonly inputRange: adaptable[]; 
  readonly outputRange: adaptable[]; 
  readonly extrapolate?: extrapolate; 
  readonly extrapolateLeft?: extrapolate; 
  readonly extrapolateRight?: extrapolate
};

// tslint:disable-next-line:interface-over-type-literal
export type multiOperator = (_1:adaptable, _2:adaptable, _3:adaptable[]) => node;

// tslint:disable-next-line:interface-over-type-literal
export type unaryOperator = (_1:adaptable) => node;

// tslint:disable-next-line:interface-over-type-literal
export type binaryOperator = (_1:adaptable, _2:adaptable) => node;

// tslint:disable-next-line:interface-over-type-literal
export type animationState = {
  readonly finished: animatedValue; 
  readonly position: animatedValue; 
  readonly time: animatedValue
};

// tslint:disable-next-line:interface-over-type-literal
export type physicsState = { readonly animationState: animationState; readonly velocity: animatedValue };

// tslint:disable-next-line:interface-over-type-literal
export type SpringAnimation_config = {
  readonly damping: adaptable; 
  readonly mass: adaptable; 
  readonly stiffness: adaptable; 
  readonly overshootClamping: adaptable; 
  readonly restSpeedThreshold: adaptable; 
  readonly restDisplacementThreshold: adaptable; 
  readonly toValue: adaptable
};

// tslint:disable-next-line:interface-over-type-literal
export type TimingAnimation_state = { readonly animationState: animationState; readonly frameTime: animatedValue };

// tslint:disable-next-line:interface-over-type-literal
export type TimingAnimation_config = { readonly toValue: adaptable; readonly duration: adaptable };

export const AnimatedAdaptable_ofString: (_1:string) => AnimatedAdaptable_t = AnimatedBS.AnimatedAdaptable.ofString;

export const AnimatedAdaptable_ofFloat: (_1:number) => AnimatedAdaptable_t = AnimatedBS.AnimatedAdaptable.ofFloat;

export const AnimatedAdaptable_ofBool: (_1:boolean) => AnimatedAdaptable_t = AnimatedBS.AnimatedAdaptable.ofBool;

export const AnimatedValue_ofString: (_1:string, _2:number) => AnimatedValue_t = function (Arg1: any, Arg2: any) {
  const result = Curry._2(AnimatedBS.AnimatedValue.ofString, Arg1, Arg2);
  return result
};

export const AnimatedValue_ofFloat: (_1:number, _2:number) => AnimatedValue_t = function (Arg1: any, Arg2: any) {
  const result = Curry._2(AnimatedBS.AnimatedValue.ofFloat, Arg1, Arg2);
  return result
};

export const AnimatedValue_ofBool: (_1:boolean, _2:number) => AnimatedValue_t = function (Arg1: any, Arg2: any) {
  const result = Curry._2(AnimatedBS.AnimatedValue.ofBool, Arg1, Arg2);
  return result
};

export const AnimatedNode_toAdaptable: (_1:AnimatedNode_t) => AnimatedAdaptable_t = AnimatedBS.AnimatedNode.toAdaptable;

export const AnimatedNode_make: (_1:AnimatedValue_t) => AnimatedNode_t = AnimatedBS.AnimatedNode.make;

export const Clock_operationToNode: (_1:Clock_operation) => AnimatedNode_t = AnimatedBS.Clock.operationToNode;

export const Clock_toNode: (_1:Clock_t) => AnimatedNode_t = AnimatedBS.Clock.toNode;

export const Clock_make: (_1:number) => Clock_t = AnimatedBS.Clock.make;

export const interpolate: (_1:adaptable, _2:interpolationConfig) => node = function (Arg1: any, Arg2: any) {
  const result = AnimatedBS.interpolate(Arg1, {inputRange:Arg2.inputRange, outputRange:Arg2.outputRange, extrapolate:(Arg2.extrapolate == null ? undefined : $$toRE922137290[Arg2.extrapolate]), extrapolateLeft:(Arg2.extrapolateLeft == null ? undefined : $$toRE922137290[Arg2.extrapolateLeft]), extrapolateRight:(Arg2.extrapolateRight == null ? undefined : $$toRE922137290[Arg2.extrapolateRight])});
  return result
};

export const add: multiOperator = AnimatedBS.add;

export const sub: multiOperator = AnimatedBS.sub;

export const multiply: multiOperator = AnimatedBS.multiply;

export const divide: multiOperator = AnimatedBS.divide;

export const pow: multiOperator = AnimatedBS.pow;

export const modulo: multiOperator = AnimatedBS.modulo;

export const and_: multiOperator = AnimatedBS.and_;

export const or_: multiOperator = AnimatedBS.or_;

export const sqrt: unaryOperator = AnimatedBS.sqrt;

export const log: unaryOperator = AnimatedBS.log;

export const sin: unaryOperator = AnimatedBS.sin;

export const cos: unaryOperator = AnimatedBS.cos;

export const tan: unaryOperator = AnimatedBS.tan;

export const acos: unaryOperator = AnimatedBS.acos;

export const asin: unaryOperator = AnimatedBS.asin;

export const atan: unaryOperator = AnimatedBS.atan;

export const exp: unaryOperator = AnimatedBS.exp;

export const round: unaryOperator = AnimatedBS.round;

export const floor: unaryOperator = AnimatedBS.floor;

export const ceil: unaryOperator = AnimatedBS.ceil;

export const defined: unaryOperator = AnimatedBS.defined;

export const not_: unaryOperator = AnimatedBS.not_;

export const max: binaryOperator = AnimatedBS.max;

export const min: binaryOperator = AnimatedBS.min;

export const lessThan: binaryOperator = AnimatedBS.lessThan;

export const eq: binaryOperator = AnimatedBS.eq;

export const greaterThan: binaryOperator = AnimatedBS.greaterThan;

export const lessOrEq: binaryOperator = AnimatedBS.lessOrEq;

export const greaterOrEq: binaryOperator = AnimatedBS.greaterOrEq;

export const neq: binaryOperator = AnimatedBS.neq;

export const set_: (_1:animatedValue, _2:adaptable) => node = AnimatedBS.set_;

export const concat: (_1:adaptable[]) => node = AnimatedBS.concat;

export const cond: (_1:adaptable, _2:adaptable, _3:(null | undefined | adaptable)) => node = function (Arg1: any, Arg2: any, Arg3: any) {
  const result = AnimatedBS.cond(Arg1, Arg2, (Arg3 == null ? undefined : Arg3));
  return result
};

export const block: (_1:adaptable[]) => node = AnimatedBS.block;

export const debug: (_1:string, _2:node) => node = AnimatedBS.debug;

export const onChange: (_1:adaptable, _2:adaptable) => node = AnimatedBS.onChange;

export const startClock: (_1:clock) => node = AnimatedBS.startClock;

export const stopClock: (_1:clock) => node = AnimatedBS.stopClock;

export const clockRunning: (_1:clock) => node = AnimatedBS.clockRunning;

export const abs: unaryOperator = AnimatedBS.abs;

export const acc: unaryOperator = AnimatedBS.acc;

export const diff: unaryOperator = AnimatedBS.diff;

export const color: (_1:adaptable, _2:adaptable, _3:adaptable, _4:(null | undefined | adaptable)) => node = function (Arg1: any, Arg2: any, Arg3: any, Arg4: any) {
  const result = AnimatedBS.color(Arg1, Arg2, Arg3, (Arg4 == null ? undefined : Arg4));
  return result
};

export const diffClamp: (_1:adaptable, _2:adaptable, _3:adaptable) => node = AnimatedBS.diffClamp;

export const decay: (_1:clock, _2:physicsState, _3:adaptable) => node = AnimatedBS.decay;

export const timing: (_1:clock, _2:TimingAnimation_state, _3:TimingAnimation_config) => node = AnimatedBS.timing;

export const spring: (_1:clock, _2:physicsState, _3:SpringAnimation_config) => node = AnimatedBS.spring;

export const AnimatedValue: {
  ofString: (_1:string, _2:number) => AnimatedValue_t; 
  ofFloat: (_1:number, _2:number) => AnimatedValue_t; 
  ofBool: (_1:boolean, _2:number) => AnimatedValue_t
} = AnimatedBS.AnimatedValue

export const AnimatedNode: { toAdaptable: (_1:AnimatedNode_t) => AnimatedAdaptable_t; make: (_1:AnimatedValue_t) => AnimatedNode_t } = AnimatedBS.AnimatedNode

export const AnimatedAdaptable: {
  ofString: (_1:string) => AnimatedAdaptable_t; 
  ofFloat: (_1:number) => AnimatedAdaptable_t; 
  ofBool: (_1:boolean) => AnimatedAdaptable_t
} = AnimatedBS.AnimatedAdaptable

export const Clock: {
  operationToNode: (_1:Clock_operation) => AnimatedNode_t; 
  toNode: (_1:Clock_t) => AnimatedNode_t; 
  make: (_1:number) => Clock_t
} = AnimatedBS.Clock
