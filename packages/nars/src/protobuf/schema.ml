(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
   Source: schema.proto
   Syntax: proto3 
   Parameters:
     annot=''
     debug=false
     opens=[]
     int64_as_int=false
     int32_as_int=true
     fixed_as_int=false
     singleton_record=false
*)
module rec StringValue : sig
  val name': unit -> string
  type t = string 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.StringValue"
  type t = string 
  let to_proto t = 
    let apply = fun ~f a -> f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun a -> a in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and Int32Value : sig
  val name': unit -> string
  type t = int 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.Int32Value"
  type t = int 
  let to_proto t = 
    let apply = fun ~f a -> f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun a -> a in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and Callback : sig
  val name': unit -> string
  type t = int 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.Callback"
  type t = int 
  let to_proto t = 
    let apply = fun ~f a -> f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun a -> a in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and LocalProp : sig
  val name': unit -> string
  type t = { localKey: string; propKey: string } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.LocalProp"
  type t = { localKey: string; propKey: string } 
  let to_proto t = 
    let apply = fun ~f:f' { localKey; propKey } -> f' localKey propKey in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun localKey propKey -> { localKey; propKey } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and CustomComponent : sig
  val name': unit -> string
  type t = { type_id: string; contents: bytes } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.CustomComponent"
  type t = { type_id: string; contents: bytes } 
  let to_proto t = 
    let apply = fun ~f:f' { type_id; contents } -> f' type_id contents in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic (1, string, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun type_id contents -> { type_id; contents } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and View : sig
  val name': unit -> string
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; children: ReactElement.t list } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.View"
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; children: ReactElement.t list } 
  let to_proto t = 
    let apply = fun ~f:f' { style; children } -> f' style children in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.to_proto)) ^:: repeated (2, (message ReactElement.to_proto), not_packed) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun style children -> { style; children } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.from_proto)) ^:: repeated (2, (message ReactElement.from_proto), not_packed) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and FlatList : sig
  val name': unit -> string
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; onEndReached: Callback.t option; onEndReachedThreshold: Int32Value.t option; children: ReactElement.t list; localProps: LocalProp.t list } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.FlatList"
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; onEndReached: Callback.t option; onEndReachedThreshold: Int32Value.t option; children: ReactElement.t list; localProps: LocalProp.t list } 
  let to_proto t = 
    let apply = fun ~f:f' { style; onEndReached; onEndReachedThreshold; children; localProps } -> f' style onEndReached onEndReachedThreshold children localProps in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.to_proto)) ^:: basic_opt (2, (message Callback.to_proto)) ^:: basic_opt (3, (message Int32Value.to_proto)) ^:: repeated (4, (message ReactElement.to_proto), not_packed) ^:: repeated (5, (message LocalProp.to_proto), not_packed) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun style onEndReached onEndReachedThreshold children localProps -> { style; onEndReached; onEndReachedThreshold; children; localProps } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.from_proto)) ^:: basic_opt (2, (message Callback.from_proto)) ^:: basic_opt (3, (message Int32Value.from_proto)) ^:: repeated (4, (message ReactElement.from_proto), not_packed) ^:: repeated (5, (message LocalProp.from_proto), not_packed) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and TouchableOpacity : sig
  val name': unit -> string
  type t = { onPress: Callback.t option; children: ReactElement.t list; localProps: LocalProp.t list } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.TouchableOpacity"
  type t = { onPress: Callback.t option; children: ReactElement.t list; localProps: LocalProp.t list } 
  let to_proto t = 
    let apply = fun ~f:f' { onPress; children; localProps } -> f' onPress children localProps in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic_opt (1, (message Callback.to_proto)) ^:: repeated (2, (message ReactElement.to_proto), not_packed) ^:: repeated (3, (message LocalProp.to_proto), not_packed) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun onPress children localProps -> { onPress; children; localProps } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic_opt (1, (message Callback.from_proto)) ^:: repeated (2, (message ReactElement.from_proto), not_packed) ^:: repeated (3, (message LocalProp.from_proto), not_packed) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and RawText : sig
  val name': unit -> string
  type t = string 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.RawText"
  type t = string 
  let to_proto t = 
    let apply = fun ~f a -> f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun a -> a in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and Text : sig
  val name': unit -> string
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; children: ReactElement.t list } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.Text"
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; children: ReactElement.t list } 
  let to_proto t = 
    let apply = fun ~f:f' { style; children } -> f' style children in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.to_proto)) ^:: repeated (2, (message ReactElement.to_proto), not_packed) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun style children -> { style; children } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.from_proto)) ^:: repeated (2, (message ReactElement.from_proto), not_packed) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and TextInput : sig
  val name': unit -> string
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; placeholderTextColor: StringValue.t option; placeholder: StringValue.t option; value: string; localProps: LocalProp.t list; onValueChange: Callback.t option } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.TextInput"
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; placeholderTextColor: StringValue.t option; placeholder: StringValue.t option; value: string; localProps: LocalProp.t list; onValueChange: Callback.t option } 
  let to_proto t = 
    let apply = fun ~f:f' { style; placeholderTextColor; placeholder; value; localProps; onValueChange } -> f' style placeholderTextColor placeholder value localProps onValueChange in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.to_proto)) ^:: basic_opt (2, (message StringValue.to_proto)) ^:: basic_opt (3, (message StringValue.to_proto)) ^:: basic (4, string, proto3) ^:: repeated (5, (message LocalProp.to_proto), not_packed) ^:: basic_opt (6, (message Callback.to_proto)) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun style placeholderTextColor placeholder value localProps onValueChange -> { style; placeholderTextColor; placeholder; value; localProps; onValueChange } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.from_proto)) ^:: basic_opt (2, (message StringValue.from_proto)) ^:: basic_opt (3, (message StringValue.from_proto)) ^:: basic (4, string, proto3) ^:: repeated (5, (message LocalProp.from_proto), not_packed) ^:: basic_opt (6, (message Callback.from_proto)) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and Switch : sig
  val name': unit -> string
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; value: bool; onValueChange: Callback.t option } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.Switch"
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; value: bool; onValueChange: Callback.t option } 
  let to_proto t = 
    let apply = fun ~f:f' { style; value; onValueChange } -> f' style value onValueChange in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.to_proto)) ^:: basic (2, bool, proto3) ^:: basic_opt (3, (message Callback.to_proto)) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun style value onValueChange -> { style; value; onValueChange } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.from_proto)) ^:: basic (2, bool, proto3) ^:: basic_opt (3, (message Callback.from_proto)) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and Image : sig
  val name': unit -> string
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; sourceURLString: string } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.Image"
  type t = { style: Struct.Google_mirror.Protobuf.Struct.t option; sourceURLString: string } 
  let to_proto t = 
    let apply = fun ~f:f' { style; sourceURLString } -> f' style sourceURLString in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.to_proto)) ^:: basic (2, string, proto3) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun style sourceURLString -> { style; sourceURLString } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic_opt (1, (message Struct.Google_mirror.Protobuf.Struct.from_proto)) ^:: basic (2, string, proto3) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and ReactElement : sig
  val name': unit -> string
  type t = { key: StringValue.t option; value: [ `Custom of CustomComponent.t | `View of View.t | `FlatList of FlatList.t | `TouchableOpacity of TouchableOpacity.t | `TextInput of TextInput.t | `Text of Text.t | `RawText of RawText.t | `Switch of Switch.t | `Image of Image.t ] } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.ReactElement"
  type t = { key: StringValue.t option; value: [ `Custom of CustomComponent.t | `View of View.t | `FlatList of FlatList.t | `TouchableOpacity of TouchableOpacity.t | `TextInput of TextInput.t | `Text of Text.t | `RawText of RawText.t | `Switch of Switch.t | `Image of Image.t ] } 
  let to_proto t = 
    let apply = fun ~f:f' { key; value } -> f' key value in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic_opt (1, (message StringValue.to_proto)) ^:: oneof ((function `Custom v -> oneof_elem (2, (message CustomComponent.to_proto), v) | `View v -> oneof_elem (3, (message View.to_proto), v) | `FlatList v -> oneof_elem (4, (message FlatList.to_proto), v) | `TouchableOpacity v -> oneof_elem (5, (message TouchableOpacity.to_proto), v) | `TextInput v -> oneof_elem (6, (message TextInput.to_proto), v) | `Text v -> oneof_elem (7, (message Text.to_proto), v) | `RawText v -> oneof_elem (8, (message RawText.to_proto), v) | `Switch v -> oneof_elem (9, (message Switch.to_proto), v) | `Image v -> oneof_elem (10, (message Image.to_proto), v))) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun key value -> { key; value } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic_opt (1, (message StringValue.from_proto)) ^:: oneof ([ oneof_elem (2, (message CustomComponent.from_proto), fun v -> `Custom v); oneof_elem (3, (message View.from_proto), fun v -> `View v); oneof_elem (4, (message FlatList.from_proto), fun v -> `FlatList v); oneof_elem (5, (message TouchableOpacity.from_proto), fun v -> `TouchableOpacity v); oneof_elem (6, (message TextInput.from_proto), fun v -> `TextInput v); oneof_elem (7, (message Text.from_proto), fun v -> `Text v); oneof_elem (8, (message RawText.from_proto), fun v -> `RawText v); oneof_elem (9, (message Switch.from_proto), fun v -> `Switch v); oneof_elem (10, (message Image.from_proto), fun v -> `Image v) ]) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and Unmount : sig
  val name': unit -> string
  type t = unit 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.Unmount"
  type t = unit 
  let to_proto t = 
    let apply = fun ~f () -> f in
    let spec = Ocaml_protoc_plugin.Serialize.C.( nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = () in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and Render : sig
  val name': unit -> string
  type t = { name: string; props: Struct.Google_mirror.Protobuf.Struct.t option; localProps: string list } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.Render"
  type t = { name: string; props: Struct.Google_mirror.Protobuf.Struct.t option; localProps: string list } 
  let to_proto t = 
    let apply = fun ~f:f' { name; props; localProps } -> f' name props localProps in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message Struct.Google_mirror.Protobuf.Struct.to_proto)) ^:: repeated (3, string, packed) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun name props localProps -> { name; props; localProps } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message Struct.Google_mirror.Protobuf.Struct.from_proto)) ^:: repeated (3, string, packed) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and Call : sig
  val name': unit -> string
  type t = { messageId: int; args: Struct.Google_mirror.Protobuf.Struct.t option } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.Call"
  type t = { messageId: int; args: Struct.Google_mirror.Protobuf.Struct.t option } 
  let to_proto t = 
    let apply = fun ~f:f' { messageId; args } -> f' messageId args in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic (1, int32_int, proto3) ^:: basic_opt (2, (message Struct.Google_mirror.Protobuf.Struct.to_proto)) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun messageId args -> { messageId; args } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic (1, int32_int, proto3) ^:: basic_opt (2, (message Struct.Google_mirror.Protobuf.Struct.from_proto)) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and ClientToServer : sig
  val name': unit -> string
  type t = { rootId: int; value: [ `Unmount of Unmount.t | `Render of Render.t | `Call of Call.t ] } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.ClientToServer"
  type t = { rootId: int; value: [ `Unmount of Unmount.t | `Render of Render.t | `Call of Call.t ] } 
  let to_proto t = 
    let apply = fun ~f:f' { rootId; value } -> f' rootId value in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic (1, int32_int, proto3) ^:: oneof ((function `Unmount v -> oneof_elem (2, (message Unmount.to_proto), v) | `Render v -> oneof_elem (3, (message Render.to_proto), v) | `Call v -> oneof_elem (4, (message Call.to_proto), v))) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun rootId value -> { rootId; value } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic (1, int32_int, proto3) ^:: oneof ([ oneof_elem (2, (message Unmount.from_proto), fun v -> `Unmount v); oneof_elem (3, (message Render.from_proto), fun v -> `Render v); oneof_elem (4, (message Call.from_proto), fun v -> `Call v) ]) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and Error : sig
  val name': unit -> string
  type t = unit 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.Error"
  type t = unit 
  let to_proto t = 
    let apply = fun ~f () -> f in
    let spec = Ocaml_protoc_plugin.Serialize.C.( nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = () in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and Update : sig
  val name': unit -> string
  type t = ReactElement.t list 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.Update"
  type t = ReactElement.t list 
  let to_proto t = 
    let apply = fun ~f a -> f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.( repeated (1, (message ReactElement.to_proto), not_packed) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun a -> a in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( repeated (1, (message ReactElement.from_proto), not_packed) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
and ServerToClient : sig
  val name': unit -> string
  type t = { rootId: int; value: [ `Error of Error.t | `Update of Update.t ] } 
  val to_proto: t -> Ocaml_protoc_plugin.Writer.t
  val from_proto: Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct 
  let name' () = "Schema.ServerToClient"
  type t = { rootId: int; value: [ `Error of Error.t | `Update of Update.t ] } 
  let to_proto t = 
    let apply = fun ~f:f' { rootId; value } -> f' rootId value in
    let spec = Ocaml_protoc_plugin.Serialize.C.( basic (1, int32_int, proto3) ^:: oneof ((function `Error v -> oneof_elem (2, (message Error.to_proto), v) | `Update v -> oneof_elem (3, (message Update.to_proto), v))) ^:: nil ) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize (spec) in
    apply ~f:(serialize ()) t
  
  let from_proto writer = 
    let constructor = fun rootId value -> { rootId; value } in
    let spec = Ocaml_protoc_plugin.Deserialize.C.( basic (1, int32_int, proto3) ^:: oneof ([ oneof_elem (2, (message Error.from_proto), fun v -> `Error v); oneof_elem (3, (message Update.from_proto), fun v -> `Update v) ]) ^:: nil ) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize (spec) constructor in
    deserialize writer
  
end
