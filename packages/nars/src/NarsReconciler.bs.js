// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Instance = require("./Instance.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_SetString = require("bs-platform/lib/js/belt_SetString.js");
var Belt_HashMapInt = require("bs-platform/lib/js/belt_HashMapInt.js");
var ReactReconciler = require("react-reconciler");
var ComponentRegistry = require("./ComponentRegistry.bs.js");

function createInstance(instance_type, props, _rootContainer, context, _opaqueFiber) {
  console.log("createInstance");
  var match = ComponentRegistry.get(instance_type);
  if (match !== undefined) {
    var key = Curry._1(context[/* generateId */0], /* () */0);
    return /* Component */Block.__(1, [/* record */[
                /* encode */Curry._2(match, key, props),
                /* key */key,
                /* children : array */[]
              ]]);
  } else {
    return Pervasives.invalid_arg("Unknown component type " + instance_type);
  }
}

var counter = /* record */[/* contents */0];

var defaultRootHostContext = /* record */[/* generateId */(function (param) {
      counter[0] = counter[0] + 1 | 0;
      return String(counter[0]);
    })];

function getPublicInstance(x) {
  return x;
}

function getRootHostContext(param) {
  return defaultRootHostContext;
}

function getChildHostContext(param, parentType, param$1) {
  console.log("Get child context of " + parentType);
  var counter = /* record */[/* contents */0];
  return /* record */[/* generateId */(function (param) {
              counter[0] = counter[0] + 1 | 0;
              return String(counter[0]);
            })];
}

function prepareForCommit(param) {
  return /* () */0;
}

function resetAfterCommit(container) {
  Belt_HashMapInt.clear(container[/* callbackRegistry */2]);
  var counter = /* record */[/* contents */0];
  var registerCallback = function (callback) {
    var id = counter[0];
    counter[0] = counter[0] + 1 | 0;
    Belt_HashMapInt.set(container[/* callbackRegistry */2], id, callback);
    return id;
  };
  var children = container[/* children */1].map((function (inst) {
          return Instance.encode(inst, registerCallback);
        }));
  Curry._1(container[/* flushUpdates */0], children);
  return /* () */0;
}

function assertComponentInstance(instance, f) {
  if (instance.tag) {
    return Curry._1(f, instance[0]);
  } else {
    return Pervasives.invalid_arg("Cannot append children to RawText");
  }
}

function appendInitialChild(parentInstance, child) {
  assertComponentInstance(parentInstance, (function (parentInstance) {
          return parentInstance[/* children */2].push(child);
        }));
  return /* () */0;
}

function finalizeInitialChildren(param, param$1, param$2, param$3, _hostContext) {
  return false;
}

function prepareUpdate(param, param$1, oldProps, newProps, param$2, param$3) {
  var changedProps = /* array */[];
  var newSet = Belt_SetString.fromArray(Object.keys(newProps));
  var oldSet = Belt_SetString.fromArray(Object.keys(oldProps));
  Belt_SetString.forEachU(Belt_SetString.union(newSet, oldSet), (function (key) {
          if (Js_dict.get(newProps, key) !== Js_dict.get(oldProps, key)) {
            changedProps.push(key);
            return /* () */0;
          } else {
            return /* () */0;
          }
        }));
  return changedProps;
}

function createTextInstance(text, param, param$1, param$2) {
  return /* RawText */Block.__(0, [(function (param) {
                return ComponentRegistry.createRawTextEncodedReactElement(text);
              })]);
}

function shouldSetTextContent(param, _props) {
  return false;
}

function shouldDeprioritizeSubtree(param, param$1) {
  return false;
}

function mountEventComponent(param) {
  return Pervasives.failwith("Event components are not implemented");
}

function handleEventTarget(param) {
  return Pervasives.failwith("Event components are not implemented");
}

function commitEventTarget(param) {
  return Pervasives.failwith("Event components are not implemented");
}

function getChildHostContextForEventComponent(param) {
  return Pervasives.failwith("Event components are not implemented");
}

function getChildHostContextForEventTarget(param) {
  return Pervasives.failwith("Event components are not implemented");
}

function getEventTargetChildElement(param, param$1) {
  return Pervasives.failwith("Event components are not implemented");
}

function appendChild(parent, child) {
  return assertComponentInstance(parent, (function (parentInstance) {
                var index = parentInstance[/* children */2].findIndex((function (x) {
                        return child === x;
                      }));
                if (index >= 0) {
                  parentInstance[/* children */2].splice(index, 1, child);
                  return /* () */0;
                } else {
                  return appendInitialChild(parent, child);
                }
              }));
}

function appendChildToContainer(container, child) {
  console.log("APPEND to container");
  container[/* children */1].push(child);
  return /* () */0;
}

function commitMount(param, param$1, param$2, param$3) {
  return /* () */0;
}

function commitUpdate(instance, param, instance_type, param$1, props, param$2) {
  var match = ComponentRegistry.get(instance_type);
  if (match !== undefined) {
    if (instance.tag) {
      var instance$1 = instance[0];
      instance$1[/* encode */0] = Curry._2(match, instance$1[/* key */1], props);
      return /* () */0;
    } else {
      return Pervasives.invalid_arg("Cannot update component type " + instance_type);
    }
  } else {
    return Pervasives.invalid_arg("Cannot update component type " + instance_type);
  }
}

function insertBefore(parent, child, beforeChild) {
  console.log("Insert");
  return assertComponentInstance(parent, (function (parentInstance) {
                var index = parentInstance[/* children */2].findIndex((function (x) {
                        return beforeChild === x;
                      }));
                parentInstance[/* children */2].splice(index, 0, child);
                return /* () */0;
              }));
}

function insertInContainerBefore(container, child, beforeChild) {
  console.log("Insert in container before");
  var index = container[/* children */1].findIndex((function (x) {
          return beforeChild === x;
        }));
  container[/* children */1].splice(index, 0, child);
  return /* () */0;
}

function removeChild(parent, child) {
  console.log("Remove");
  return assertComponentInstance(parent, (function (parent) {
                var pos = parent[/* children */2].findIndex((function (x) {
                        return child === x;
                      }));
                parent[/* children */2].splice(pos, 1);
                return /* () */0;
              }));
}

function removeChildFromContainer(parent, child) {
  console.log("Remove from container");
  var pos = parent[/* children */1].findIndex((function (x) {
          return child === x;
        }));
  parent[/* children */1].splice(pos, 1);
  return /* () */0;
}

function hideInstance(param) {
  return /* () */0;
}

function unhideInstance(param, param$1) {
  return /* () */0;
}

function commitTextUpdate(param, param$1, param$2) {
  return /* () */0;
}

function hideTextInstance(param) {
  return /* () */0;
}

function unhideTextInstance(param, param$1) {
  return /* () */0;
}

function resetTextContent(param) {
  return /* () */0;
}

var reconciler = ReactReconciler({
      supportsMutation: true,
      getPublicInstance: getPublicInstance,
      getRootHostContext: getRootHostContext,
      getChildHostContext: getChildHostContext,
      prepareForCommit: prepareForCommit,
      resetAfterCommit: resetAfterCommit,
      createInstance: createInstance,
      appendInitialChild: appendInitialChild,
      finalizeInitialChildren: finalizeInitialChildren,
      prepareUpdate: prepareUpdate,
      createTextInstance: createTextInstance,
      shouldSetTextContent: shouldSetTextContent,
      shouldDeprioritizeSubtree: shouldDeprioritizeSubtree,
      now: (function (prim) {
          return Date.now();
        }),
      cancelTimeout: (function (prim) {
          clearTimeout(prim);
          return /* () */0;
        }),
      scheduleTimeout: (function (prim, prim$1) {
          return setTimeout(prim, prim$1);
        }),
      noTimeout: -1,
      isPrimaryRenderer: true,
      mountEventComponent: mountEventComponent,
      handleEventTarget: handleEventTarget,
      commitEventTarget: commitEventTarget,
      getChildHostContextForEventComponent: getChildHostContextForEventComponent,
      getChildHostContextForEventTarget: getChildHostContextForEventTarget,
      getEventTargetChildElement: getEventTargetChildElement,
      appendChild: appendChild,
      appendChildToContainer: appendChildToContainer,
      commitMount: commitMount,
      commitUpdate: commitUpdate,
      insertBefore: insertBefore,
      insertInContainerBefore: insertInContainerBefore,
      removeChild: removeChild,
      removeChildFromContainer: removeChildFromContainer,
      hideInstance: hideInstance,
      unhideInstance: unhideInstance,
      commitEventTarget: commitEventTarget,
      commitTextUpdate: commitTextUpdate,
      hideTextInstance: hideTextInstance,
      unhideTextInstance: unhideTextInstance,
      resetTextContent: resetTextContent
    });

function createContainer(flushUpdates) {
  var registry = Belt_HashMapInt.make(50);
  var opaqueRoot = reconciler.createContainer(/* record */[
        /* flushUpdates */flushUpdates,
        /* children : array */[],
        /* callbackRegistry */registry
      ]);
  return /* record */[
          /* registry */registry,
          /* opaqueRoot */opaqueRoot
        ];
}

function updateContainer(element, container) {
  return reconciler.updateContainer(element, container[/* opaqueRoot */1]);
}

function unbatchedUpdates(f) {
  return reconciler.unbatchedUpdates(f);
}

function invokeCallback(container, messageId, args) {
  var match = Belt_HashMapInt.get(container[/* registry */0], messageId);
  if (match !== undefined) {
    return Curry._1(match, args);
  } else {
    return /* () */0;
  }
}

function batchedUpdates(f) {
  return reconciler.batchedUpdates(f, /* () */0);
}

function flushPassiveEffects(param) {
  return reconciler.flushPassiveEffects();
}

var isThisRendererActing = reconciler.IsThisRendererActing;

exports.createContainer = createContainer;
exports.updateContainer = updateContainer;
exports.unbatchedUpdates = unbatchedUpdates;
exports.invokeCallback = invokeCallback;
exports.batchedUpdates = batchedUpdates;
exports.flushPassiveEffects = flushPassiveEffects;
exports.isThisRendererActing = isThisRendererActing;
/* reconciler Not a pure module */
